#!/bin/bash

# Default values
log_files=("/var/log/dnsmasq.log")  # Default log file
min_count=400                       # Default minimum count
save_file=""                        # No save file by default
grep_pattern=""                     # No pattern means show all

# Show help
show_help() {
  cat << EOF
Usage: $(basename "$0") [-f logfile(s)] [-m minimum_count] [-s save_file] [-a | -b]

Description:
  Analyzes dnsmasq logs and counts domain occurrences.

Options:
  -f <files>         Specify log files or patterns (default: /var/log/dnsmasq.log).
  -m <number>        Minimum occurrence count (default: 400).
  -s <file>          Save output to the specified file.
  -a                 Filter "reply" entries.
  -b                 Filter "NXDOMAIN" entries.
  -h                 Show this help message.

Examples:
  $(basename "$0") -a -m 500                      # Filter "reply" with min count 500
  $(basename "$0") -b -s ~/output.txt             # Filter "NXDOMAIN" and save results
  $(basename "$0") -f "/var/log/backups/*" -m 100 # No pattern, shows all entries
EOF
}

# Parse flags
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h ) show_help; exit 0 ;;
    -f )
      shift
      log_files=()
      while [[ $# -gt 0 && ! "$1" =~ ^- ]]; do
        log_files+=( "$1" )
        shift
      done
      ;;
    -m )
      shift
      [[ "$1" =~ ^[0-9]+$ ]] && min_count="$1" || { echo "❌ -m requires a number."; exit 1; }
      shift
      ;;
    -s )
      shift
      [[ -n "$1" && ! "$1" =~ ^- ]] && save_file="$1" || { echo "❌ -s requires a file path."; exit 1; }
      shift
      ;;
    -a ) grep_pattern="reply"; shift ;;
    -b ) grep_pattern="NXDOMAIN"; shift ;;
    * )
      echo "❌ Unknown option: $1"
      show_help
      exit 1
      ;;
  esac
done
# Expand globs and verify files
valid_files=()
for pattern in "${log_files[@]}"; do
  matched_files=( $(compgen -G "$pattern") )
  [[ ${#matched_files[@]} -gt 0 ]] && valid_files+=( "${matched_files[@]}" ) || echo "⚠ Warning: No files matched - $pattern"
done

[[ ${#valid_files[@]} -eq 0 ]] && { echo "❌ No valid log files found."; exit 1; }

# Prepare for capturing output
final_output=""

#echo "🔍 Searching entries in:"
final_output="🔍 Searching entries in: \n"
for file in "${valid_files[@]}"; do final_output+=" $file \n \n"; done
#echo "🔢 Minimum occurrences: $min_count"
final_output+="🔢 Minimum occurrences: $min_count\n\n"
[[ -n "$grep_pattern" ]] && echo "🔎 Filtering pattern: \"$grep_pattern\"" || echo "🌐 Showing both NXDOMAIN and reply entries."

# Process logs
if [[ -n "$grep_pattern" ]]; then
  # If -a or -b filter is set, use that to filter
  output=$(grep "$grep_pattern" "${valid_files[@]}" | \
    awk '{for (i=1; i<=NF; i++) if ($i ~ /^[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/) print tolower($i)}' | \
    sort | uniq -c | awk -v min="$min_count" '$1 >= min' | sort -nr)
  final_output+="🔎 Filtering pattern: \"$grep_pattern\"\n$output"
else
  # If no pattern filter is specified, show both NXDOMAIN and reply
  final_output+="--- NXDOMAIN entries ---\n"
  output_nxdomain=$(grep "NXDOMAIN" "${valid_files[@]}" | \
    awk '{for (i=1; i<=NF; i++) if ($i ~ /^[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/) print tolower($i)}' | \
    sort | uniq -c | awk -v min="$min_count" '$1 >= min' | sort -nr)
  final_output+="$output_nxdomain\n"

  final_output+="\n--- reply entries ---\n"
  output_reply=$(grep "reply" "${valid_files[@]}" | \
    awk '{for (i=1; i<=NF; i++) if ($i ~ /^[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/) print tolower($i)}' | \
    sort | uniq -c | awk -v min="$min_count" '$1 >= min' | sort -nr)
  final_output+="$output_reply"
fi

# Display output on screen
echo -e "$final_output"

# Save the output to the file if -s flag is used
if [[ -n "$save_file" ]]; then
  echo -e "$final_output" > "$save_file"
  echo "💾 Results saved to: $save_file"
fi
