#!/bin/bash

# Default values
log_files=("/var/log/dnsmasq.log")  # Default log file
min_count=400                       # Default minimum count
save_file=""                        # No save file by default
grep_pattern=""                     # No pattern means show all
watch_flag=false                    # Watch mode disabled by default

# Show help
show_help() {
  cat << EOF
Usage: $(basename "$0") [-f logfile(s)] [-m minimum_count] [-s save_file] [-a | -b] [-w]

Description:
  Analyzes dnsmasq logs and counts domain occurrences.

Options:
  -f <files>         Specify log files or patterns (default: /var/log/dnsmasq.log).
  -m <number>        Minimum occurrence count (default: 400).
  -s <file>          Save output to the specified file.
  -a                 Filter "reply" entries.
  -b                 Filter "NXDOMAIN" entries.
  -w                 Watch output every 0.5 seconds.
  -h                 Show this help message.

Examples:
  $(basename "$0") -a -m 500                      # Filter "reply" with min count 500
  $(basename "$0") -b -s ~/output.txt             # Filter "NXDOMAIN" and save results
  $(basename "$0") -f "/var/log/backups/*" -m 100 # Show all entries
  $(basename "$0") -w                             # Watch output every 0.5 seconds
EOF
}

# Process logs and generate output
process_logs() {
  final_output="üîç Searching entries in:\n"
  for file in "${valid_files[@]}"; do final_output+=" $file\n"; done
  final_output+="\nüî¢ Minimum occurrences: $min_count\n"

  [[ -n "$grep_pattern" ]] && final_output+="üîé Filtering pattern: \"$grep_pattern\"\n"

  if [[ -n "$grep_pattern" ]]; then
    output=$(grep "$grep_pattern" "${valid_files[@]}" | \
      awk '{for (i=1; i<=NF; i++) if ($i ~ /^[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/) print tolower($i)}' | \
      sort | uniq -c | awk -v min="$min_count" '$1 >= min' | sort -nr)
    final_output+="$output"
  else
    final_output+="\nüåê Monitoring Both NXDOMAIN and reply\n\n--- NXDOMAIN entries ---\n"
    output_nxdomain=$(grep "NXDOMAIN" "${valid_files[@]}" | \
      awk '{for (i=1; i<=NF; i++) if ($i ~ /^[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/) print tolower($i)}' | \
      sort | uniq -c | awk -v min="$min_count" '$1 >= min' | sort -nr)
    final_output+="$output_nxdomain\n"

    final_output+="\n--- reply entries ---\n"
    output_reply=$(grep "reply" "${valid_files[@]}" | \
      awk '{for (i=1; i<=NF; i++) if ($i ~ /^[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/) print tolower($i)}' | \
      sort | uniq -c | awk -v min="$min_count" '$1 >= min' | sort -nr)
    final_output+="$output_reply"
  fi

  # Display output
  clear
  echo -e "$final_output"

  # Save if requested
  if [[ -n "$save_file" ]]; then
    echo -e "$final_output" > "$save_file"
    echo "üíæ Results saved to: $save_file"
  fi
}

# Parse flags
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h ) show_help; exit 0 ;;
    -f )
      shift
      log_files=()
      while [[ $# -gt 0 && ! "$1" =~ ^- ]]; do
        log_files+=( "$1" )
        shift
      done
      ;;
    -m )
      shift
      [[ "$1" =~ ^[0-9]+$ ]] && min_count="$1" || { echo "‚ùå -m requires a number."; exit 1; }
      shift
      ;;
    -s )
      shift
      [[ -n "$1" && ! "$1" =~ ^- ]] && save_file="$1" || { echo "‚ùå -s requires a file path."; exit 1; }
      shift
      ;;
    -a ) grep_pattern="reply"; shift ;;
    -b ) grep_pattern="NXDOMAIN"; shift ;;
    -w ) watch_flag=true; shift ;;
    * )
      echo "‚ùå Unknown option: $1"
      show_help
      exit 1
      ;;
  esac
done

# Expand globs and verify files
valid_files=()
for pattern in "${log_files[@]}"; do
  matched_files=( $(compgen -G "$pattern") )
  [[ ${#matched_files[@]} -gt 0 ]] && valid_files+=( "${matched_files[@]}" ) || echo "‚ö† Warning: No files matched - $pattern"
done

[[ ${#valid_files[@]} -eq 0 ]] && { echo "‚ùå No valid log files found."; exit 1; }

# Execute watch mode or process once
if $watch_flag; then
  echo "üëÄ Watching logs... Press Ctrl+C to stop."
  while true; do
    process_logs
    sleep 0.5
  done
else
  process_logs
fi
